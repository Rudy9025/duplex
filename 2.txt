What you just described is exactly what the custom query in your LoginRepository is doing, just written in Java with JPA syntax instead of raw SQL.

But if you want the most direct SQL-like approach, here’s how to write native SQL instead of JPQL:

⸻

✅ Modified LoginRepository with Native SQL Query:

package com.example.demo.repository;

import com.example.demo.model.Login;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface LoginRepository extends JpaRepository<Login, Long> {

    @Query(value = "SELECT * FROM devusers WHERE uid = :uid AND password = :password", nativeQuery = true)
    Login login(@Param("uid") Long uid, @Param("password") String password);
}



⸻

✅ Controller to check credentials:

package com.example.demo.controller;

import com.example.demo.model.Login;
import com.example.demo.repository.LoginRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class LoginController {

    @Autowired
    private LoginRepository loginRepository;

    @PostMapping("/login")
    public String login(@RequestBody Login login) {
        Login result = loginRepository.login(login.getUid(), login.getPassword());

        if (result != null) {
            return "success";
        } else {
            return "invalid credentials";
        }
    }
}



⸻

Notes:
	•	You are now running this SQL:

SELECT * FROM devusers WHERE uid = ? AND password = ?


	•	The result is checked. If a row is found, you return "success", else "invalid credentials".
	•	Make sure your Login.java entity class has @Id on uid, like this:

@Id
@Column(name = "uid")
private Long uid;



Do you want this to return JSON instead of plain text?