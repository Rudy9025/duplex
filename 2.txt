Sure! Below is the **full working example Java code** that uses AWS SDK v2 and **disables SSL verification** (for development use only). It creates an `S3Client` that ignores certificate errors, such as `PKIX path building failed`.

---

### ‚úÖ Full Example: Upload a File to S3 with SSL Verification Disabled

#### üîß Assumptions:

* You're using **AWS SDK v2**
* Your file is a `MultipartFile` from a Spring Boot controller
* Bucket name and region are known
* This is for **development or internal use only**

---

### üì¶ 1. Add Maven Dependency (if not already)

Add this to your `pom.xml`:

```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>s3</artifactId>
    <version>2.25.0</version> <!-- Or latest -->
</dependency>
```

---

### üß† 2. Create the S3 Client Factory

```java
import software.amazon.awssdk.http.SdkHttpClient;
import software.amazon.awssdk.http.apache.ApacheHttpClient;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;

import javax.net.ssl.*;
import java.security.cert.X509Certificate;

public class S3ClientFactory {

    public static S3Client createUnsafeS3Client() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[0];
                }
            }
        };

        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());

        HostnameVerifier allHostsValid = (hostname, session) -> true;

        SdkHttpClient httpClient = ApacheHttpClient.builder()
                .sslSocketFactory(sslContext.getSocketFactory())
                .hostnameVerifier(allHostsValid)
                .build();

        return S3Client.builder()
                .httpClient(httpClient)
                .region(Region.AP_SOUTH_1) // Replace with your region
                .build();
    }
}
```

---

### üßæ 3. Use It in a Spring Boot Service

```java
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;
import software.amazon.awssdk.core.sync.RequestBody;

import java.io.IOException;

@Service
public class S3Service {

    private final String bucketName = "your-bucket-name"; // Replace with your actual bucket

    public String uploadFile(MultipartFile file) throws Exception {
        S3Client s3Client = S3ClientFactory.createUnsafeS3Client();

        String key = file.getOriginalFilename(); // or UUID.randomUUID() + extension

        PutObjectRequest putObjectRequest = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(key)
                .build();

        s3Client.putObject(putObjectRequest, RequestBody.fromBytes(file.getBytes()));

        return "https://" + bucketName + ".s3.amazonaws.com/" + key;
    }
}
```

---

### ‚úÖ 4. Controller Example (Optional)

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class UploadController {

    @Autowired
    private S3Service s3Service;

    @PostMapping("/upload")
    public String upload(@RequestParam("file") MultipartFile file) throws Exception {
        return s3Service.uploadFile(file);
    }
}
```

---

### ‚úÖ Done!

You should now be able to upload files even when your corporate proxy or cert chain is broken.

---

Would you like a version that **uses a proper truststore instead of disabling cert validation**? That would be safer for production use.
























public class MainApplication {
    public static void main(String[] args) {
        // Disable AWS SDK SSL certificate validation (‚ö†Ô∏è for testing only)
        System.setProperty("com.amazonaws.sdk.disableCertChecking", "true");

        SpringApplication.run(MainApplication.class, args);
    }
}






@PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public ResponseEntity<Map<String, String>> upload(@RequestPart("file") MultipartFile file) {
    try {
        System.out.println("Received file: " + file.getOriginalFilename());

        String key = s3Service.uploadFile(file); // üî• likely failing here
        String url = s3Service.generatePresignedUrl(key);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Upload successful");
        response.put("url", url);
        return ResponseEntity.ok(response);
    } catch (Exception e) {
        // Print full stack trace for debugging
        e.printStackTrace();

        // Return the error to frontend
        Map<String, String> error = new HashMap<>();
        error.put("error", "Upload failed: " + e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
